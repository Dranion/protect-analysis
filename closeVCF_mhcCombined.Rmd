---
title: "Finding Missing Variants"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
---


```{r include=FALSE}
#libraries. may not all be necessary
library(VariantAnnotation)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library("org.Hs.eg.db") # remember to install it if you don't have it already
library(tidyverse)
library(eulerr)
library(gridExtra)
library(dplyr)
```

```{r}
#and setup 
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
baselineName <- "CHR6_NOVAR"
compareName <- "CHR6_SUBTRACTED"
```

Note: this depends on mhciBindingList and mhciiBindingList as generated by analysis.Rmd. 
'Luckily', it will fail if baselineName and compareName are not the same. 
```{r}
mhcBindingList <- read_rds("mhcBindingList.rds")
mhciBindingList <- read_rds("mhciBindingList.rds")
mhciiBindingList <- read_rds("mhciiBindingList.rds")
```



## Evaluating Binding Predictions 

### Combining mhci, mhcii from analysis.Rmd 
```{r}
bindingMHCI <- bind_rows("base" = mhciBindingList[[paste0("binding", "mhci", ".", baselineName)]],"comp" = mhciBindingList[[paste0("binding", "mhci", ".", compareName)]] , .id = "src")


bindingMHCII <- bind_rows("base" = mhciiBindingList[[paste0("binding", "mhcii", ".", baselineName)]],"comp" = mhciiBindingList[[paste0("binding", "mhcii", ".", compareName)]] , .id = "src")

binding <- bind_rows("mhci" = bindingMHCI, "mhcii" = bindingMHCII, .id="mhc")
binding <- separate_rows(binding,ENST, sep=",")
```

### Transcript Analysis 
Getting (manually annotated, from gnomad ENST status). Seperated from details because wasn't looked up with those (only "ENST")
```{r}
enstSearch <- read_csv("enstSearch-2021-02-19.csv") %>% separate(ENST, c("ENST", "ENST.detail"), sep="_")
```

Putting into one big binding file with status. 
```{r}
binding <- binding %>% separate(ENST, c("ENST", "ENST.detail"), sep="_")
for(i in 1:nrow(binding)){
  binding[i,"Status"] <- unique(enstSearch[enstSearch$ENST == binding[i,]$ENST, 'ENST Status'])
}

```

```{r}
binding %>%  summarize(uniqueGenes = n_distinct(gene),uniqueENST= n_distinct(ENST))
binding %>%  group_by(src,Status) %>%  summarize(uniqueGenes = n_distinct(gene),uniqueENST= n_distinct(ENST))
```

### Somatics Only ENST Comparison 
```{r}
bindingMHCII %>% group_by(src, gene) %>% summarize(uniqueENST= n_distinct(ENST))

somatics <- filter(binding, Status=="Somatic") %>% group_by(src) 
somatic <- list(baseline = filter(somatics, src=="base"), compare = filter(somatics, src=="comp"))
fullList <- somatic
comparison <- "ENST"

uniqueSomatic <- somatic
for( i in seq_along(uniqueSomatic)){
  uniqueSomatic[i] <- unique(uniqueSomatic[[i]][comparison])
}
test <- euler(uniqueSomatic, shape = "ellipse")
grid.arrange(grobs = list(
  plot(euler(uniqueSomatic, shape = "ellipse"), quantities = TRUE, legend = TRUE )),
  top = paste("Somatics Only", comparison, "Comparison"))
```

```{r eval=FALSE, include=FALSE}
# removed since this means less info downstream. 

#THESE ARE THE ONES WE'RE WORRIED ABOUT AND NEED TO EXAMINE IN THE VCF:
#missingSomaticENST <- filter(somatic$baseline, ENST %in% setdiff(uniqueSomatic$baseline, uniqueSomatic$compare))
#though we need to remove the extra 
#missingSomaticENST <- separate(missingSomaticENST,ENST, c("ENST", "ENST.detail"), sep="_")
```

## Getting the VCFs 
```{r}
getVCF = function(sample, which){
  mutations <- read.delim(paste(sample, "mutations", which, "mutations.vcf",sep="/"), header=FALSE, comment.char="#")
  relevant <- c("CHROM",	"POS",	"ID",	"REF",	"ALT",	"QUAL",	"FILTER",	"INFO")
  names(mutations) <- relevant
  return(mutations[,1:8])
}
KVsep <- fixed(";")
Vsep <- fixed("=")

which <- "transgened"
baseline <- getVCF(baselineName, which) %>%
  mutate(split = str_split(INFO, KVsep)) %>%
  unnest(split) %>%
  separate(split, into = c("key", "value"), Vsep) %>%
  spread(key, value) %>%
  select(-INFO) %>%
  mutate(coverage = str_replace(coverage, "[.]", "")) %>%  mutate(coverage = str_replace(coverage, ",", "")) %>%mutate(coverage = str_replace(coverage, "[,-]", ""))	%>%  mutate(coverage = str_replace(coverage, "[.]", "")) %>% 
  separate(coverage, into = c("supporting_reads", "overall_reads"), "/") %>% mutate(coverage = as.numeric(supporting_reads)/as.numeric(overall_reads))
compare <- getVCF(compareName, which) %>%
  mutate(split = str_split(INFO, KVsep)) %>%
  unnest(split) %>%
  separate(split, into = c("key", "value"), Vsep) %>%
  spread(key, value) %>%
  select(-INFO) %>% 
   mutate(coverage = str_replace(coverage, "[.]", "")) %>%  mutate(coverage = str_replace(coverage, ",", "")) %>%mutate(coverage = str_replace(coverage, "[,-]", ""))	%>%  mutate(coverage = str_replace(coverage, "[.]", "")) %>% 
  separate(coverage, into = c("supporting_reads", "overall_reads"), "/") %>% mutate(coverage = as.numeric(supporting_reads)/as.numeric(overall_reads))

```
### Baseline VCF
```{r}
head(baseline)
```
### Comparison VCF 
```{r}
head(compare)
```
## Direct Look at VCFs

## Adding binding prediction information to VCFs
For the baseline vcf: 
```{r echo=TRUE, message=FALSE, warning=FALSE}
baselineVCFInterest <- baseline[FALSE,]
for(variant in 1:nrow(baseline)) {
  baseline[variant,]
  for(testENST in unique(binding$ENST)){
    if(grepl(testENST, baseline[variant,"EFF"])){
      baseline[variant,"ENST"] <- testENST
      # is mhci or mhcii 
      baseline[variant,"isMHCI"] <- testENST %in% filter(binding, mhc == "mhci")$ENST
      baseline[variant,"isMHCII"] <- testENST %in% filter(binding, mhc == "mhcii")$ENST
      baseline[variant,"isBase"] <- testENST %in% filter(binding, src == "base")$ENST
      baseline[variant,"isComp"] <- testENST %in% filter(binding, src == "comp")$ENST
      baselineVCFInterest <- rbind(baselineVCFInterest, baseline[variant,])
    }
  }
}
head(baselineVCFInterest)
```

For the compare vcf:
```{r echo=TRUE, message=FALSE, warning=FALSE}
compareVCFInterest <- compare[FALSE,]
for(variant in 1:nrow(compare)) {
  for(testENST in unique(binding$ENST)){
    if(grepl(testENST, compare[variant,"EFF"])){
      compare[variant,"ENST"] <- testENST
      # is mhci or mhcii 
      compare[variant,"isMHCI"] <- testENST %in% filter(binding, mhc == "mhci")$ENST
      compare[variant,"isMHCII"] <- testENST %in% filter(binding, mhc == "mhcii")$ENST
      compare[variant,"isBase"] <- testENST %in% filter(binding, src == "base")$ENST
      compare[variant,"isComp"] <- testENST %in% filter(binding, src == "comp")$ENST
      compareVCFInterest <- rbind(compareVCFInterest, compare[variant,])
    }
  }
}
head(compareVCFInterest)
```

### Removing Duplicates
there's a lot of duplicate reads in the transgene vcfs. what's different about them is the INFO field, but we have no way of telling the difference, and none of that information is really used. 
```{r}
compareVCFInterest <- compareVCFInterest %>% distinct(CHROM, POS, ID, REF, ALT, FILTER, isMHCI, isMHCII, isBase, isComp, .keep_all = TRUE)
baselineVCFInterest <- baselineVCFInterest %>% distinct(CHROM, POS, ID, REF, ALT, FILTER, isMHCI, isMHCII, isBase, isComp, .keep_all = TRUE)

```


### Quick Stats
There are `r length(unique(binding$ENST))` ENST transcripts. Of those, `r length(unique(baselineVCFInterest$ENST))` (`r 100*length(unique(baselineVCFInterest$ENST))/length(unique(binding$ENST))`%) are in baseline and  `r length(unique(compareVCFInterest$ENST))` (`r 100*length(unique(compareVCFInterest$ENST))/length(unique(binding$ENST))`%) are in 

There are `r count(compare)` variants in comparison, `r count(na.omit(compare))` of which have a transcript in binding predictions. Of those, `r count(na.omit(compare) %>% filter(FILTER=="PASS"))` are 'PASS'. 

There are `r count(baseline)` variants in baseline, `r count(na.omit(baseline))` of which have a transcript in binding predictions. Of those, `r count(na.omit(baseline) %>% filter(FILTER=="PASS"))` are 'PASS'. 



## Analyze low hanging fruit 

'low hanging fruit' -> transcripts in the compare transgene, that are in baseline bp but NOT the compare bp
```{r}
lowFruit <- filter(compareVCFInterest, isBase & !(isComp))
lowFruit %>% summarise(pos_distinct=n_distinct(POS),distinct=n_distinct(POS,REF,ALT),overall=n())
```


```{r}
lowFruit %>% group_by(FILTER) %>% summarise(pos_distinct=n_distinct(POS),distinct=n_distinct(POS,REF,ALT),overall=n())
```



Since we're looking at a **transcript** level, there's a good chance that what we're interested in is where the real *variant* actually got rejected. 
```{r}
lowestFruit <- filter(lowFruit, FILTER=="PASS")
head(lowestFruit)
```


```{r}
positions <- as.character(paste(unique(lowFruit$POS), collapse='" "'))
writeLines(paste0('("', positions , '")'))
```

## Analyze mid fruit
Anything where the statuses are different. First with the compareVCF
```{r}
compareVCFInterest <- compareVCFInterest %>% filter(FILTER=="PASS") %>% mutate(Positive_Truth = !(!isBase & isComp)) #in the VCF but not in 
baselineVCFInterest <- baselineVCFInterest %>% filter(FILTER=="PASS") %>% mutate(Negative_Truth = !(isBase & !isComp))
```
then the baseline vcf
```{r}
midBaseFruit <- filter(baselineVCFInterest, isBase != isComp & FILTER=="PASS") #in DNA but not in RNA 
head(midBaseFruit)
midBaseFruit %>% group_by(FILTER) %>% summarise(pos_distinct=n_distinct(POS),distinct=n_distinct(POS,REF,ALT),overall=n())
positions <- as.character(paste(unique(midBaseFruit$POS), collapse='" "'))
writeLines(paste0('("', positions , '")'))
```

### Looking at VCF details

```{r}
compares = bind_rows("RNA"=compareVCFInterest, "DNA"=baselineVCFInterest, .id="Type")
compares <- compares %>% mutate(match = (isBase == isComp)) %>% mutate(supporting_reads = as.numeric(supporting_reads)) %>%  mutate(overall_reads = as.numeric(overall_reads))


compares %>% filter(FILTER=="PASS") %>% group_by(Type, match) %>% summarise(pos_distinct=n_distinct(POS),distinct=n_distinct(POS,REF,ALT),overall=n(),coverage=median(coverage),supporting_reads=median(supporting_reads),overall_reads=median(overall_reads))

coverage_plot <- ggplot(compares %>% filter(FILTER=="PASS"),aes(match, coverage,fill=match,color=match))  + geom_violin(alpha=0.2)  + geom_jitter(alpha=0.9,width=0.3) + theme_minimal() + facet_wrap(vars(Type))

coverage_plot 

support_plot <- ggplot(compares %>% filter(FILTER=="PASS"),aes(match, supporting_reads,fill=match,color=match)) + geom_violin(alpha=0.2) + geom_jitter(alpha=0.9,width=0.3) + theme_minimal()  + facet_wrap( vars(Type), scales="free_y") 

support_plot

support_plot +  coord_cartesian(ylim = c(0, 150))

reads_plot <- ggplot(compares %>% filter(FILTER=="PASS"),aes(match, overall_reads,fill=match,color=match)) + geom_violin(alpha=0.2) + geom_jitter(alpha=0.9,width=0.3) + theme_minimal()  +facet_wrap( vars(Type), scales = "free_y")

reads_plot

reads_plot + coord_cartesian(ylim = c(0, 300))


ggplot(compares, aes(overall_reads, coverage, color=match)) + geom_point() + facet_grid(Type ~ FILTER)
```
```{r}
false_pos <- as.numeric(unique(filter(compareVCFInterest, FILTER=="PASS" & !isBase & isComp)$POS)) #in RNA but not in DNA 
false_neg <- as.numeric(unique(filter(baselineVCFInterest, FILTER=="PASS" & isBase & !isComp)$POS)) #in DNA but not in RNA 

examine <- bind_rows("DNA"=baseline, "RNA"=compare, .id="src") %>% mutate(status = case_when(POS %in% false_pos & src == "RNA" ~ 'False Positive',
                           POS %in% false_neg & src =="DNA" ~ 'False Negative',
                           TRUE ~ '-'))

ggplot(examine %>% filter(FILTER=="PASS") %>% mutate(overall_reads=as.numeric(overall_reads)), aes(overall_reads, coverage, color=status)) + geom_point() + facet_grid(rows=vars(src)) + scale_color_manual(values=c("-"="#55555522", "False Negative"="red", "False Positive"="blue")) +  coord_cartesian(xlim = c(0, 3000)) 


ggplot(examine, aes(POS, coverage, color=status)) + geom_point() + facet_grid(src ~ FILTER) + scale_color_manual(values=c("-"="#55555522", "False Negative"="red", "False Positive"="blue"))


base <- ggplot(examine %>% filter(POS %in% false_pos | POS %in% false_neg) %>% mutate(POS = as.factor(POS))) + scale_color_manual(values=c("-"="#555555", "False Negative"="red", "False Positive"="blue")) +  scale_fill_manual(values=c("-"="#555555", "False Negative"="red", "False Positive"="blue"))
main <- base +  geom_col(aes(POS, coverage, color=status, fill=status),position="stack")  

main 

main + facet_wrap(vars(src))

main + facet_wrap(vars(FILTER))
```


```{r eval=FALSE, include=FALSE}
#BiocManager::install("signeR")

library(signeR)
library(VariantAnnotation)

# BSgenome, equivalent to the one used on the variant call
library(BSgenome.Hsapiens.UCSC.hg38)

vcfobjBaseline <- readVcf(paste(baselineName, "mutations", which, "mutations.vcf",sep="/"), "hg38")
vcfobjCompare <- readVcf(paste(compareName, "mutations", which, "mutations.vcf",sep="/"), "hg38")
mutBaseline <- genCountMatrixFromVcf(BSgenome.Hsapiens.UCSC.hg38, vcfobjBaseline)

```

```{r eval=FALSE, include=FALSE}
Other things that have been thrown away. 
# rd <- rowRanges(baseline)
# baseMHC <- mhciBindingList[[paste0("binding", "mhci", ".", baselineName)]]$gene
# compMHC <- mhciBindingList[[paste0("binding", "mhci", ".", compareName)]]$gene
# geneDiff <- setdiff(baseMHC, compMHC) #appears in BASE but not in COMP 
# 
# baseLoc <- locateVariants(rowRanges(baseline), txdb, AllVariants())
# compLoc <- locateVariants(rowRanges(compare), txdb, AllVariants())
# 
# #baseInBase <- filter(baseMHC, )
# #baseInComp
# #compInBase
# #compInComp <<- 
# 
# 
# grabVCFGenes = function(loc, diff, txdb) {
#   ## Summarize the number of coding variants by gene ID.
#   splt <- split(mcols(loc)$QUERYID, mcols(loc)$GENEID)
#   numVariants <- sapply(splt, function(x) length(unique(x)))
#   numVariants
#   byGene <- as.data.frame(numVariants)
#   
#   byGene$ENTREZID <- rownames(byGene)
#   byGene$ALIAS <- mapIds(org.Hs.eg.db, keys = byGene$ENTREZID, keytype = "ENTREZID", column="ALIAS")
#   
#   return(filter(byGene, ENTREZID %in% diff)) 
# }
# 
# baselineGene <- grabVCFGenes(baseLoc, entrezDiff, txdb) 
# compareGene <- grabVCFGenes(compLoc, entrezDiff, txdb) 
# head(baselineGene)
# head(compareGene)
# baselineGene %>% summarise(num=n(), mean=mean(numVariants))
# compareGene %>% summarise(num=n(), mean=mean(numVariants))
# 
# 
# #library(biomaRt)
# 
# #ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
# #filters = listFilters(ensembl)
```

```{r include=FALSE}
file.copy(from = "closeVCF.pdf", 
          to = paste0('closeVCF_',lubridate::today(),'_',paste0(lubridate::hour(lubridate::now()), 
          lubridate::minute(lubridate::now())),'.pdf'))
``` 
